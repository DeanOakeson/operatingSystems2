#ifndef KERNEL_H
#define KERNEL_H

#include "ram.h"
#include "vm.h"
#include <bits/stdc++.h>
#include <hashtable.h>
#include <stdio.h>
#include <stdlib.h>

class Kernel {
public:
  VirtualMachine Machine;
  std::string filePath;
  std::vector<int> errorList;

  /////////////////////
  // ERROR HANDELING //
  /////////////////////

  void errorDump() {
    printf("working\n");
    for (int i = 0; i < sizeof(errorList); i++) {
      printf("%d", errorList[i]);
    }
  }

  void initHardware(VirtualMachine newMachine) { Machine = newMachine; }

  //////////////////////
  // CPU SYSTEM CALLS //
  //////////////////////
  ///
  /// CPU ERRORS 1, 2, 3

  void coreDump() {
    u_int8_t regId = 0;

    printf("\nCORE_DUMP  \n=========");
    for (u_int8_t i = 0; i < 6; i++) {
      printf("\nREGISTER:: [ %d ] -- [ %d ]", regId, Machine.reg[regId]);
      regId += 1;
    }
    printf("\nREGISTER:: [ PC ] -- [ %d ] \nREGISTER:: [ Z ] -- [ %d ]\n\n",
           Machine.PC, Machine.Z);
  }

  int runProgram() {
    Machine.runCpu();
    return 0;
  }

  //////////////////////
  // MEM SYSTEM CALLS //
  //////////////////////
  ///
  /// MEM ERRORS 4, 5 ,6

  int loadProgram(std::string FilePath) {
    std::ifstream file(FilePath, std::ios::binary);
    // FIGURE THIS SHIT OUT

    if (file.fail()) {
      std::ios_base::iostate state = file.rdstate();

      if (state & std::ios_base::eofbit) {
        errorList.push_back(23);
        return 23; // END OF FILE REACED FAIL
      }
      if (state & std::ios_base::failbit) {
        errorList.push_back(24);
        return 24; // NON_FATAL I/O ERROR OCCURED
      }
      if (state & std::ios_base::failbit) {
        errorList.push_back(25);
        return 25; // FATAL ERROR OCCURED
      }
    }

    // FIRST READ THE FIRST 3 INTS FOR HEADER VARIABLES //
    file.read(reinterpret_cast<char *>(&Machine.MainMemory.fileSize),
              sizeof(u_int32_t));
    file.read(
        reinterpret_cast<char *>(&Machine.MainMemory.fileFirstInstruction),
        sizeof(u_int32_t));
    file.read(reinterpret_cast<char *>(&Machine.MainMemory.fileLoadAddress),
              sizeof(u_int32_t));

    // TRANSLATE INTO 6 BYTE ADDRESS SPACE
    Machine.MainMemory.fileSize = Machine.MainMemory.fileSize / 6;

    // FILE SIZE EXCEEDS MEMORY
    if (Machine.MainMemory.fileLoadAddress + Machine.MainMemory.fileSize >
        MEM_SIZE_KB) {
      errorList.push_back(21);
      return 21;
    }

    // MEMORY IS OCCUPIED
    if (verifyMemoryIsUnoccupied() != true) {
      errorList.push_back(22);
      return 22;
    }

    for (u_int32_t i = Machine.MainMemory.fileLoadAddress;
         i < Machine.MainMemory.fileSize + Machine.MainMemory.fileLoadAddress;
         i++) {
      for (u_int32_t j = 0; j < 6; j++) {
        file.read(reinterpret_cast<char *>(&Machine.MainMemory.mem[i][j]),
                  sizeof(unsigned char));
      }

      return 0; // SUCCESS
    }

    updateMemoryIndicators();

    filePath = FilePath;
    return 0;
  }

  int memDump() {
    if (Machine.MainMemory.fileSize == 0) { // IF NO FILE HAS BEEN LOADED
      printf("\n --NO LOADED PROGRAM-- \n");
      return 1; // 1 memDump means no load
    }
    printf("\nERROR_DUMP  \n===========\nADDRESSES::[ %d - "
           "%d ]\nPROGRAM::[ %s ]\n",
           Machine.MainMemory.fileLoadAddress,
           Machine.MainMemory.fileLoadAddress + Machine.MainMemory.fileSize,
           filePath.c_str());
    for (int i = Machine.MainMemory.fileLoadAddress;
         i < Machine.MainMemory.fileLoadAddress + Machine.MainMemory.fileSize;
         i++) {
      printf("\nADDRESS::[ %d ] -- ", i);
      for (int j = 0; j <= 6; j++) {
        printf("[ %d ]", Machine.MainMemory.mem[i][j]);
      }
    }
    printf("\n\n");
    return 0;
  }

private:
  /////////////////////////////
  // MEMORY HELPER FUNCTIONS //
  /////////////////////////////

  // CHECKS ALL POSITIONS FOR THE TO BE LOADED PROGRAM //
  bool verifyMemoryIsUnoccupied() {
    for (u_char i = Machine.MainMemory.fileLoadAddress;
         i <= Machine.MainMemory.fileLoadAddress + Machine.MainMemory.fileSize;
         i++) {
      if (Machine.MainMemory.mem[i][6] == 1) {
        return false;
      }
    }
    return true;
  }

  // FLIPS THE MEMORY OCCUPATION BIT //
  void updateMemoryIndicators() {
    for (u_int32_t i = Machine.MainMemory.fileLoadAddress;
         i <= Machine.MainMemory.fileLoadAddress + Machine.MainMemory.fileSize;
         i++) {
      if (Machine.MainMemory.mem[i][6] == 0)
        Machine.MainMemory.mem[i][6] = 1;
      else if (Machine.MainMemory.mem[i][6] == 1)
        Machine.MainMemory.mem[i][6] = 0;
    }
  }
};

#endif
